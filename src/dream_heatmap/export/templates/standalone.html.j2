<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{{ title }}</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');
  body {
    margin: 0;
    padding: 24px;
    font-family: "Outfit", system-ui, -apple-system, sans-serif;
    background: #fafbfc;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  #heatmap-container {
    position: relative;
    display: inline-block;
  }
  #heatmap-container canvas {
    display: block;
  }
  #heatmap-container svg {
    position: absolute;
    top: 0;
    left: 0;
  }
  .dh-info {
    margin-top: 14px;
    font-size: 11px;
    color: #94a3b8;
    letter-spacing: 0.01em;
  }
  {{ css_source }}
</style>
</head>
<body>
<div id="heatmap-container" class="dh-container"></div>
<div class="dh-info">Generated by dream-heatmap</div>

<script>
// === Embedded data ===
const MATRIX_B64 = "{{ matrix_b64 }}";
const COLOR_LUT_B64 = "{{ color_lut_b64 }}";
const LAYOUT_DATA = {{ layout_json }};
const ID_MAPPERS_DATA = {{ id_mappers_json }};
const CONFIG_DATA = {{ config_json }};

// Base64 → ArrayBuffer
function b64ToArrayBuffer(b64) {
  const bin = atob(b64);
  const len = bin.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) bytes[i] = bin.charCodeAt(i);
  return bytes.buffer;
}

// === Inline JS classes ===
{{ js_source }}

// === Zoom helpers for standalone mode ===

/**
 * Extract a sub-matrix from a row-major Float64Array.
 */
function extractSubMatrix(matrix, origNCols, rowStart, rowEnd, colStart, colEnd) {
  var nRows = rowEnd - rowStart;
  var nCols = colEnd - colStart;
  var sub = new Float64Array(nRows * nCols);
  for (var r = 0; r < nRows; r++) {
    for (var c = 0; c < nCols; c++) {
      sub[r * nCols + c] = matrix[(rowStart + r) * origNCols + (colStart + c)];
    }
  }
  return sub;
}

/**
 * Build a zoomed layout object for the given sub-range.
 */
function buildZoomedLayout(origLayout, nRows, nCols, cellSize) {
  var padding = 40;
  var heatmapX = padding;
  var heatmapY = padding;
  var heatmapW = nCols * cellSize;
  var heatmapH = nRows * cellSize;

  var rowPositions = [];
  for (var r = 0; r < nRows; r++) rowPositions.push(heatmapY + r * cellSize);
  var colPositions = [];
  for (var c = 0; c < nCols; c++) colPositions.push(heatmapX + c * cellSize);

  return {
    heatmap: { x: heatmapX, y: heatmapY, width: heatmapW, height: heatmapH },
    rowPositions: rowPositions,
    colPositions: colPositions,
    rowCellSize: cellSize,
    colCellSize: cellSize,
    totalWidth: heatmapX + heatmapW + padding,
    totalHeight: heatmapY + heatmapH + padding,
    nRows: nRows,
    nCols: nCols,
    rowDendroWidth: 0,
    colDendroHeight: 0,
    hasColorBar: origLayout.hasColorBar || false,
    rightAnnotationWidth: 0,
    bottomAnnotationHeight: 0,
  };
}

/**
 * Build a zoomed IDResolver from the original mapper data.
 */
function buildZoomedResolver(origMapperData, positions, cellSize, start, end) {
  if (!origMapperData) return null;
  var sliced = origMapperData.visual_order.slice(start, end);
  return new IDResolver(
    { visual_order: sliced, gap_positions: [], size: sliced.length },
    positions,
    cellSize
  );
}

// === Standalone render ===
(function() {
  var container = document.getElementById("heatmap-container");

  var canvas = document.createElement("canvas");
  container.appendChild(canvas);

  var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg.style.position = "absolute";
  svg.style.top = "0";
  svg.style.left = "0";
  container.appendChild(svg);

  var tooltip = document.createElement("div");
  tooltip.className = "dh-tooltip";
  container.appendChild(tooltip);

  // Initialize components
  var canvasRenderer = new CanvasRenderer(canvas);
  var svgOverlay = new SVGOverlay(svg);
  svgOverlay.setTooltip(tooltip);
  var colorBarRenderer = new ColorBarRenderer(svg);
  var legendRenderer = new LegendRenderer(svg);
  var hoverHandler = new HoverHandler(svg, tooltip, svgOverlay, container);

  // Decode original data (stored in closure for zoom reuse)
  var matrixBuf = b64ToArrayBuffer(MATRIX_B64);
  var lutBuf = b64ToArrayBuffer(COLOR_LUT_B64);
  var origLayout = LAYOUT_DATA;
  var origConfig = CONFIG_DATA;

  if (!origLayout || !origLayout.nRows || !origLayout.nCols) {
    container.textContent = "No data to render.";
    return;
  }

  var origMatrix = decodeMatrixBytes(matrixBuf);
  var lut = decodeColorLUT(lutBuf);
  var colorMapper = new ColorMapper(lut, origConfig.vmin, origConfig.vmax, origConfig.nanColor);

  /**
   * Render the heatmap. If zoomRange is provided, render a zoomed sub-view.
   * zoomRange = {row_start, row_end, col_start, col_end} or null for full.
   */
  function doRender(zoomRange) {
    var layout, matrix, rowResolver, colResolver, showDendrograms, showAnnotations, showLabels;

    if (zoomRange) {
      // Zoomed view
      var rs = zoomRange.row_start, re = zoomRange.row_end;
      var cs = zoomRange.col_start, ce = zoomRange.col_end;
      var nRows = re - rs;
      var nCols = ce - cs;

      matrix = extractSubMatrix(origMatrix, origLayout.nCols, rs, re, cs, ce);

      // Compute cell size to fill a reasonable area
      var autoW = 500 / nCols;
      var autoH = 400 / nRows;
      var cellSize = Math.max(1, Math.min(50, Math.max(origLayout.rowCellSize, Math.min(autoW, autoH))));
      layout = buildZoomedLayout(origLayout, nRows, nCols, cellSize);

      rowResolver = buildZoomedResolver(ID_MAPPERS_DATA.row, layout.rowPositions, layout.rowCellSize, rs, re);
      colResolver = buildZoomedResolver(ID_MAPPERS_DATA.col, layout.colPositions, layout.colCellSize, cs, ce);

      // Skip dendrograms/annotations in zoomed view
      showDendrograms = false;
      showAnnotations = false;
      // Build zoomed labels from original if available
      showLabels = true;
    } else {
      // Full view
      layout = origLayout;
      matrix = origMatrix;
      rowResolver = ID_MAPPERS_DATA.row
        ? new IDResolver(ID_MAPPERS_DATA.row, layout.rowPositions, layout.rowCellSize)
        : null;
      colResolver = ID_MAPPERS_DATA.col
        ? new IDResolver(ID_MAPPERS_DATA.col, layout.colPositions, layout.colCellSize)
        : null;
      showDendrograms = true;
      showAnnotations = true;
      showLabels = true;
    }

    // Clear stale selection
    svgOverlay.hideSelection();
    zoomHandler.setLastSelectionBounds(null);

    // Render heatmap cells
    canvasRenderer.render(matrix, layout, colorMapper);
    svgOverlay.resize(layout);

    // Dendrograms
    if (showDendrograms) {
      var dendrograms = origConfig.dendrograms || null;
      dendroClickHandler.setContext(layout, rowResolver, colResolver);
      svgOverlay.renderDendrograms(dendrograms, layout, function(memberIds, axis) {
        dendroClickHandler.onBranchClick(memberIds, axis);
      });
    } else {
      svgOverlay.renderDendrograms(null, layout, function() {});
    }

    // Annotations
    if (showAnnotations) {
      var annotations = origConfig.annotations || null;
      annotationClickHandler.setContext(layout, rowResolver, colResolver);
      svgOverlay.renderAnnotations(annotations, layout, function(categoryName, edge, cellLabels) {
        annotationClickHandler.onCategoryClick(categoryName, edge, cellLabels);
      });
    } else {
      svgOverlay.renderAnnotations(null, layout);
    }

    // Color bar + categorical legends (unified in legend panel)
    var legends = origConfig.legends || null;
    var colorBarTitle = origConfig.colorBarTitle || null;
    if (layout.legendPanel || layout.hasColorBar) {
      legendRenderer.render(
        legends, layout.legendPanel,
        colorBarRenderer, lut, origConfig.vmin, origConfig.vmax, colorBarTitle
      );
    } else {
      legendRenderer.clear();
      colorBarRenderer.clear();
    }

    // Labels
    if (showLabels && !zoomRange) {
      var labels = origConfig.labels || null;
      svgOverlay.renderLabels(labels, layout);
    } else if (showLabels && zoomRange && rowResolver && colResolver) {
      // Build zoomed labels
      var zoomedLabels = {};
      if (origConfig.labels && origConfig.labels.row && origConfig.labels.row.labels) {
        var rowLabels = [];
        for (var ri = 0; ri < rowResolver.size; ri++) {
          rowLabels.push({
            text: rowResolver.visualOrder[ri],
            position: layout.rowPositions[ri] + layout.rowCellSize / 2,
            visible: true,
            fontSize: 10,
          });
        }
        zoomedLabels.row = { labels: rowLabels, side: "right" };
      }
      if (origConfig.labels && origConfig.labels.col && origConfig.labels.col.labels) {
        var colLabels = [];
        for (var ci = 0; ci < colResolver.size; ci++) {
          colLabels.push({
            text: colResolver.visualOrder[ci],
            position: layout.colPositions[ci] + layout.colCellSize / 2,
            visible: true,
            fontSize: 10,
          });
        }
        zoomedLabels.col = { labels: colLabels, side: "bottom" };
      }
      svgOverlay.renderLabels(zoomedLabels, layout);
    } else {
      svgOverlay.renderLabels(null, layout);
    }

    // Update handler contexts
    hoverHandler.setContext(layout, matrix, rowResolver, colResolver, colorMapper);
    selectionHandler.setContext(layout, rowResolver, colResolver);
    zoomHandler.setContext(layout, rowResolver, colResolver);

    // Size container
    container.style.width = layout.totalWidth + "px";
    container.style.height = layout.totalHeight + "px";
  }

  // Dummy model sync for standalone — zoom triggers client-side re-render
  var dummySync = {
    setSelection: function(sel) {
      console.log("Selection:", sel.row_ids.length, "rows,", sel.col_ids.length, "cols");
    },
    setZoomRange: function(range) {
      doRender(range);
    },
  };

  var selectionHandler = new SelectionHandler(svg, svgOverlay, dummySync, hoverHandler);
  var dendroClickHandler = new DendrogramClickHandler(svgOverlay, dummySync);
  var annotationClickHandler = new AnnotationClickHandler(svgOverlay, dummySync);
  var viewport = new Viewport();
  var zoomHandler = new ZoomHandler(svg, dummySync, viewport, svgOverlay);
  selectionHandler.setZoomHandler(zoomHandler);
  dendroClickHandler.setZoomHandler(zoomHandler);
  annotationClickHandler.setZoomHandler(zoomHandler);

  // Toolbar
  var toolbar = new Toolbar(container);
  toolbar.addButton("zoomToSelection", TOOLBAR_ICONS.zoomToSelection, "Zoom to selection", function() {
    zoomHandler.zoomToSelection();
  });
  toolbar.addButton("resetZoom", TOOLBAR_ICONS.resetZoom, "Reset zoom", function() {
    zoomHandler.resetZoom();
  });
  toolbar.addButton("downloadPng", TOOLBAR_ICONS.downloadPng, "Download as PNG", function() {
    try {
      var link = document.createElement("a");
      link.download = "heatmap.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    } catch (e) {
      console.warn("Download failed:", e);
    }
  });
  toolbar.addButton("crosshairToggle", TOOLBAR_ICONS.crosshairToggle, "Toggle crosshair", function() {
    var enabled = !hoverHandler.getCrosshairEnabled();
    hoverHandler.setCrosshairEnabled(enabled);
    toolbar.setActive("crosshairToggle", enabled);
  });
  toolbar.setActive("crosshairToggle", true);

  // Initial full render
  doRender(null);
})();
</script>
</body>
</html>
